# -*- coding: utf-8 -*-
"""
Created on Tue Oct  2 00:13:34 2018

@author: carve
"""

def grasshopper1(n):
    """ Смысл такой же как и с числами фибоначчи. Сначала нужно описать решение 
    рекурсивно, далее найти базовый случай, потом начиная от базового заполняем 
    массив последующими значениями пока не дойдем до нашего.В этом варианте
    функции он, кстати, точно совпадает в числами фибоначчи.
    Не редко в подобных задачах встречается условие что ПОСЕЩЕНИЕ(именно
    посещение, а не прыжок, т.е. цена не зависит от дальности прыжка, плата за 
    вход в позицию для всех одинакова) НЕБЕСПЛАТНО, в таком случае, если именно
    посещение платное, то этот случай решается динамикой, иначе, если платным
    является прыжок, и он будет скорее всего зависеть от дальности, то думаю, 
    тогда это должно решаться как-то иначе (чем-то типа Дейкстры).
    """
    arr = [0,1] + [0] * (n-1)
    for i in range(2,n+1):
        arr[i] = arr[i-1] + arr[i-2]
    print(len(arr),n)
    print(arr)
    return arr[n]

def grasshopper2(n):
    """ В этом варианте кузнечик может прыгать на 1,2 или 3 клетки вперед
    """
    arr = [0,1,2] + [0] * (n-2)
    for i in range(3,n+1):
        arr[i] = arr[i-1] + arr[i-2] + arr[i-3]
 
def grasshopper3(n, allowed:list):
    """ В этом варианте кузнечик может прыгать на 1,2 или 3 клетки вперед и появились
    клетки куда он не может прыгать
    """
    arr = [0,1,allowed[2]] + [0] * (n-2)
    for i in range(3,n+1):
        if allowed[i]:
            arr[i] = arr[i-1] + arr[i-2] + arr[i-3]
        
def grasshopper4(n, price:list):
    """ Здесь оценивается МИНИМАЛЬНАЯ стоимость достижения заданной клетки.
    Кузнечик снова может только прыгать на 1 или 2 клетки. по сути, как я понял
    Смысл в том что, в отличие от предыдущего, вместо А[i] = A[i-1] + A[i-2]
    нужно сделать А[i] = MIN (A[i-1] , A[i-2]) + ЦЕНА_ПОСЕЩЕНИЯ_КЛЕТКИ,
    вся разница в этом.
    """
    arr = [float("-inf"), price[1], price[1] + price[2]] + [0]*(n-2)
    for i in range(3,n+1):
        arr[i] = price[i] + min(arr[i-1], arr[i-2])
    print(len(arr),n)
    print(arr)
    return arr[n]

def grasshopper5(n, price:list):
    """ Здесь думается сделать тоже самое что и в grasshopper4 только с
    запоминанием всего пути с наимаеньшей стоимостью. Для этого предлагается
    использовать дополнительный массив. TODO
    """

print(grasshopper1(4))
print(grasshopper2(4))
grasshopper4(9,[1,1,1,1,1,1,1,1,1,1])