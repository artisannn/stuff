#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

int x = 0;
std::mutex mx;


int main(int argc, char ** args)
{
    auto func = [](int id){
        for (int i = 0; i<5; i++)
        {
            mx.lock();
            std::cout << id<<"=>"<<++x<<std::endl;
            mx.unlock();
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    };
    std::thread th1(func,1);
    std::thread th2(func,2); // Объекты класса std::thread представлюят собой 
//  объекты потоков, именно ОБЪЕКТЫ, а не сами потоки. Это не одно и то же, т.е.
//  объект может сдохнуть а поток еще крутиться там, где-то, и наоборот, поток 
//  поток может завершиться спокойно, а объект его представляющий может дальше
//  и не тужить
    th1.join();     
    th2.join(); // Метод join() блокирует выполнение родительского потока
//  (т.е. того потока который эти методы вызывает(?), в данном случае поток 
//  функции main()). join нужно вызывать по той причине если главный поток 
//  завершит работу раньше th1 и th2 то он вызовет деструкторы этих объектов
//  потоков, а они-->~thread()-->std::terminate()-->abort() если флаг joinable==1
//  у этих объектов и короче прога тупо ляжет. Избежать этог есть два способа:
//  -1 Делаем join(), как выше.
//  -2 Сразу после создания о. потоков детачим их и отправляем в свободное
//  плавание: std::thread th3(func,3).detach();
//  метод detach() сбрасывает флаг joinable у о. в ноль joinable=0, тем самым 
//  избегаем той страшной цепочки, в конце которой abort(). Скорее всего, это и 
//  и есть поток сирота(?)

//  Ниже будет представлен класиеские проблемы многопоточности:

//  -1 DeadLock:
    std::mutex mx1;
    std::mutex mx2;
    auto f1 = [&](){
        mx1.lock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout<<"Trying to lock second mutex..."<<std::endl;
        mx2.lock();
        std::cout<<"Got second mutex!!!"<<std::endl;
        mx2.unlock();
        mx1.unlock();
        };

     auto f2 = [&](){
        mx2.lock();
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout<<"Trying to lock second mutex..."<<std::endl;
        mx1.lock();
        std::cout<<"Got second mutex!!!"<<std::endl;
        mx1.unlock();
        mx2.unlock();
        };
   
//    std::thread dth1(f1); // Запускать это не стоит, иначе прога зависнет
//    std::thread dth2(f2); // поэтому закоменчено.
//    dth1.join();
//    dth2.join(); 

//  -2 LiveLock:
//  Реализация будет позже. Если суть дедлока в том что два потока слишком
//  упрямые и никак не уступят друг-другу и из-за этого оба стоят и буксуют, 
//  то суть лайвлока в том что оба потока слишком вежливые и бесконечно уступают
//  друг-другу и никто не может "принять" такое щедрое предложение и поэтому
//  стоят и кланятся друг-другу вплоть до бесконечности.

//  -3 LostSignal:
//  Поток входит в состояние ожидания сигнала лишь ПОСЛЕ того как сигнал был 
//  отправлен

//  -4 AbandonedLocks:
//  Заброшенные замки возникают когда один из потоков покидает критическую секцию 
//  либо просто дохнет (от исключения, например), не освободив ресурса.
//  Обычно, чтоб избегать подобных вещей просто НЕ РАБОТАЮТ С МЬЮТЕКСАМИ.
//  вместо этого, работают с criticall section как в OpenMP
}
