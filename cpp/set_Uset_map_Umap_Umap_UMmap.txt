
Все что имеет префикс unordered_ разумеется, неотсортировано и реализовано через Hash Table

    std::unordered_map 
    std::unordered_multimap
    std::unordered_set
    std::unordered_multiset 

Все остальное реализовано через красно-черные деревья и отсортировано.



std::set - упорядоченное множетво (красно черное дерево), хранит уникальные, неповторяющиеся значения count() ---> 0,1

std::multiset - тоже самое что и выше только может хранить повторяющиеся значения count() ---> любое значение

find(x) - Возвращает итератор на первый объект в контейнере, равный x, или set::end, если такой объект отсутствует
lower_bound() - Возвращает итератор на первый объект в контейнере, который больше x, или set::end
upper_bound()
insert()
erase()
Все эти операции работают за О(logN), кроме count() он за O(N)
И все это также относится и к multiset

std::unordered_set - НЕупорядоченное множетсво. Hash Table.


std::map - хранит уникальные, неповторяющеися пары ключ-значение

Если в мапе уже есть эл-т с таким ключом, то добавить новый не получится, ничего не произойдет.
find(key) --> std::pair<key,value> обращение к ключу в этой паре происходит с помощью first(), а к значению second()
first() - константа, а second() нет. Значение меняемое, а ключ нет.
insert(std::make_pair(key,"value"))

mymap["somekey"] - обращаемся к значению по этому ключу. В multimap такое не работает. Более того, оператор [] в мапах создаст новую пару с контсрукторам по умолчанию(для значения) если пары с таким ключом не нашлось, так что даже при сравнении можно ненароком создать новый элемент в мапе, об этом нужно всегда помнить. А еще [] нельзя вызвать у константного мапа.
Для того чтоб использовать свой клас в кач-ве ключа, нужно в нем переопределить оперетор '<' или передать функтор или лямбду сравнения прямо в консркуктор мапа третьим параметром. Насколько помню, в случае unordered_map нужно еще переопределить хеш функцию в классе ключа.




std::multimap - может хранить повторяющиеся пары ключ-значение
