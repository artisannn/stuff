
/* Сокеты бывают - сокеты Беркли и Юникс сокеты, первые для взаимодейтвия по сети, вторые для межпроцессного взаимодейтсвия. 

socket(domain,type)

domain - AF_INET - сокет работающий по прототоколу IPV4
         AF_INET6 - сокет работающий по прототоколу IPV6
         AF_UNIX - Unix сокет

Интересно устроена работа Юникс сокетов. Процесс серевера создает просто пустой файл(вообщще, псевдо файл) и , цитата: "Клиенты зная имя этого файла и имея права доступа к нему могут присоединиться к сереверу". Тут скорее всего имелось ввиду что имея права доступа, клиент может считывать из файла данные или командыкоторые сервак будет класть туда и наоборот, клиент может делать записи в этот файл которые будет обрабатывать сервер, тем самым, реализуется общение меж двх отдельных процессов на одной машине, вот.

type - SOCK_STREAM - TCP
       SOCK_DGRAM - UDP

protocol - IPPROTO_TCP
           IPPROTO_UDP
обычно ставиться 0, это означает для SOCK_STREAM будет TCP, а для SOCK_DGRAM будет UDP, но можно и руками указать, те что указаны.

socket() возвращает дескриптор сокета(скорее всего файла), если два приложения подсоединяются к одному и тому же сокету, то далеко не факт что у них у обоих socket() вернет одно и то же число, т.к. у каждого процесса своя таблица дескрипторов - в ней хранится соответствие дескрипторов (число int) с соответствующим им им файлам в фаловой системе.*/

int sock = socket(AF_INET,SOCK_STREAM,0);

/*Далее привязываем сокет к IP адресу порту

bind(sock,(struct sockaddr *) sock_addr, sizeof(sa));

sock_addr - struct sock_addr_in
            struct sock_addr_in6
            struct sock_addr_un */

struct sock_addr_in sa;
sa.sin_family = AF_INET; // Дублируем domain
sa.sin_port = htons(12345);
auto ip  = INADDR_ANY;
sa.sin_addr.s_addr = htonl(ip);

bind(sock, *sa, sizeof(sa));
/*
    ip  - INADDR_LOOPBACK (127.0.0.1) адрес локальной машины
        - INADDR_ANY (0.0.0.0) любой адрес
        - Если хотим задать адрес отличный от этих двух то его нужно еще правильно "приготовить"
            - inet_addr("192.168.10.3") - но эта ф-я работает только для ipv4, воренет число которое можно отправить ip в htonl()
            - inet_ptonl(AF_INET, '192.168.10.3', & sa.sin_addr) - вданном случает даже не надо делать sa.sin_addr.s_addr = htonl(ip), она сама положит хорошо"приготовленный" ip прямо по адресу sa.sin_addr и работает для любых протоколов(по крайней мере для ipv4 и ipv6)
htons - Host to Network short (2 байта)
htonl - Host to Network long (4 байта)
ntohs - Network to Host short
ntohl - Network to Host long 
pton - Pressentation to Network
ntop -  Network to Presentation
*/
struct sock_addr_un sa; // а это уже UNIX сокет
sa.sun_family = AF_UNIX;
strcpy(sa.sun_path,"/tmp/a.sock"); // Суть данной строки: Определяемся где будем сождавать файл, желательно в папке "tmp"(это good practice), назвать можем как угодно, но для краткости назовем "а", потом присваиваем(череp копирование strcpy) к sa.sun_path путь к этому файлу. Потом при вызове bind() будет создан этот самый файл.

/* Далее пилим серверный сокет. Точнее уже запилии, забиндили, теперь будет принимать на этот сокет данные. Или отправлять.
Сокет слушается с помошью 
listen(sock,SOMAXCONN);
SOMAXCONN - Нельзя подключиться на один и тот же сокет более одного раза. Если пришло подключение, а на этот сокет уже кто-то подключился, то тот кто пришел позже встает в очередь и ждет. SOMAXCONN - системная переменная, которая определяет размер этой очереди. ОБычно, она равна 128, т.е. 129-му просто откажут, остальные будут ждать.
 Далее вызываем accept(). Когда кто-то коннектиться на этот сокет, аксептом принимаем это соединение и аксепт нам отддает новый сокет, через который мы обрабатываем конкретно этого клиента, потом идем снова в очередь принимаем следующего клиента и так далее пока не опучтеет очередь

auto s1 = accept(sock,0,0)
 На самом деле, во второй аргумент вместо нуля можем отправить указатель на пустую структуру sock_addr_in(в данном случае) и аксепт туда запишет адрес и порт кто к нам только подконнектился, но нам наплевать в данный момент поэтому кидаем туда ноль. Так же и со втрорым аргуметном - это указатель на size_t, размер этой передаваемой структуры.
*/

listen(sock,SOMAXCONN);
while(auto s1 = accept(sock,0,0))
{
    ;// здесь будет обработка с этим клиентом
}

/* Далее нам нужно писать и читать по сокету. Для этого есть ф-ии read/write(int fd, const void/void * buf, size_t count). но эти ребята могут кинуть сигнал SIGPIPE если кто-то из сторон упал, например. Конечно можно заглушить этот сигнал с помощью signal(SIGPIPE, SIG_IGN), но можно воспользоваться альтернативными ф-ми:
    size_t recv/send(int fd, const void/void * buf, size_t count, int flags)
 Кокрас) последним аргументом отправим макрос MSG_NOSIGNAL и решим проблему с SIG_PIPE.

Теперь про клиентскую часть. На клиенте создается сокет так жe как и на сервере, потом отправляется в ф-ю connect вместе со структурой sockaddr(точнее указатель на нее), в которой забит адрес серевера.

  server  client 
    |       | 
  socket() socket()
    |       |
  bind()   connect()
    |      /|
 listen() / |
    |    /  |
    |   /   |
    | SYN x |       При вызове connect() отправляется пакет со специальным флагом
    | /     |       SYN с произвольным числом x, еще до вызова accept().
    |/      |      
 accept()   |
    |\      |        
    | \     |
    |SYN k, |       Как только accept() вызвался на сервере, то его ситсема отсылает
    |ACK x+1|    ответный пакет клиенту с флагом SYN тоже с произвольным числом, и с 
    |    \  |       флагом ACK с числом отправленным клиентом увеличенным на 1
    |     \ |
    |      \|
    |      /|
    |     / |
    |    /  |
    |ACK k+1|       Теперь и клиент отправляет пакет с флагом ACK c числом больше 
    |  /    |       на 1 че то, что отправлял нам сервердо этого. Это для 
    | /     |       подтверждения того что мы получили от него пакет до этого
    |/      |
  Вот теперь соединение установлено. Метод описанный выше наз-ся тройное рукопожатие
Теперь можно вызывать recv/send, в общем работать.

После работы обрываем связь. Прежде чем убить дескрипторы с помошью close() нужно прежде вызвать shutdown(sock, flag)

flag - SHUT_RDWR - закрыть на чтение на запись
     - SHUT_RD - закрыть на чтение
     - SHUT_WR - закрыть на запись

 Закрытие:
server --> FIN M   --> client
server <-- ACK M+1 <-- client
server --> FIN N   --> client
server <-- ACK N+1 <-- client





