#include "threadobject.h"

ThreadObject::ThreadObject(int & saving, QMutex *mutex, Gender gender_flag, int sleep_interval)
    :
    _count(0),
    _interval(sleep_interval),
    _gender(gender_flag),
    _savings(saving)
{
    _mutex = mutex;
}

void ThreadObject::mainMethod()
{
    while(1)
    {
        _mutex->lock();
        if (_gender == Gender::male)
        {
            _count++;// если поменять _count на _savings, то получится борьба за общий ресурс. А так, оба потока копаются каждый в своем огороде и никто никому не мешает и ни кто никого не знает.
            qDebug()<<"I'am a man :"<<_count;// если поменять _count на _savings, то получится борьба за общий ресурс. А так, оба потока копаются каждый в своем огороде и никто никому не мешает и ни кто никого не знает.
        }
        else
        {
            _count--;// если поменять _count на _savings, то получится борьба за общий ресурс. А так, оба потока копаются каждый в своем огороде и никто никому не мешает и ни кто никого не знает.
            qDebug()<<"I'am a woman :"<<_count;// если поменять _count на _savings, то получится борьба за общий ресурс. А так, оба потока копаются каждый в своем огороде и никто никому не мешает и ни кто никого не знает.
        }
        QThread::msleep(_interval);// Слип для имитации того что один из объетов может работать оочень медленно, а другой очень быстро. И не смотря на это, благодаря синхронизации через мьютексы, каждый из объектов работает с общим ресурсом честно - один за другим, по очереди. Без мьютексов, тот что по быстрее, будет успевать делать манипуляции с общим ресурсом over 9000 раз, а другой, по медленнее, всего один, а то и вовсе ни разу. А так всве по очереди, все честно.
        _mutex->unlock();
    }
}

