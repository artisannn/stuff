Первый вариант:
	- cd <project> переходим в папку проекта
	- git init [project_name]  в текущей папке появляется папка .git или ./project_name/.git
	- git config user.name <login>	// config [--global] ;)
	- git config user.email <email> // [--global] ;)
	- git remote add <name> <url>
	- пилим настройку соединения по ssh (чтоб не вводить каждый раз логин и пароль
)
	- делаем изменения
	- git add . или отдельные файлы(это опционально)
	- git commit -m "init" -s
	- а можно сразу обе команды выполнить: git commit -am "init" -s
-am означает взять все измененные файлы, добавить в отслеживаемые и закоммитить
	- git push -u origin master  - -u означает создать локальную ветку с таким именем и локально и удаленно, итам-итам, и связать их друг с другом. После этого можно просто деалать git push

Второй вариант:
    - git clone git@github.com:whatever [folder-name] в таком случае репозиторий создаст папку не с дефолтным названием, а с названием "folder_name"

    - git checkout -b <название_ветки> origin/<название_ветки>
стаскиваем себе ветку, которой у нас до этого не было

    - git push -u origin feature/...слить ветку на удаленный репо
	
git rm --caсhed <file_name> - отменить локальные измения в файле

git fetch [имя удаленного серврера] по дефолту --all
git reset --hard origin/master - когда нужно стянуть все изменения с удаленного репо, затерев при этом локальные

git push [в какой репо] [какую ветку пушить]
git push -f - когда хотим залить наши измы поверх тех что лежат на удаленном репо. Т.е. если на удаленном лежат более свежие файлы, то они затруться. Caution!!

git stash ["comment"]
git stash pop - когда нужно просто вернуть последний сташ, без имени.
git stash apply @{<stash_comment>}

git log -5 - log -n показать последние n (5) коммитов

git show [commit_hash] - показывает изменения сделанные коммитом(default-HEAD)

ПИЛИМ НАСТРОЙКУ ПО SSH
	- открываем git bash (просто так через консоль винды может не получиться)
	- ssh-keygen
	- enter
	- вводим пароль для ssh, два раза(воде, даже лучше не вводить, но это не точно)(?)
	- идем на гитхаб -> Account setings(пользователя, а не проекта, не перепутай!!!) -> SSH keys -> add SSH key
	- туда добавляем все ключи со всех хостов на которых будем работать с этим кодом
	- задаем вменяемое имя хоста
	- копипастим ssh ключ из ~/.ssh/id_rsa.pub(открыть редактором--> ctrl+A, ctrl+C)
	- ставим галку "Allow write acces" или что-то типа этого
	- работаем и наслаждаемся.

git pull --rebase - когда ты работаешь в локальной копии ветки и кто-то слил в нее же резаультат своей недельной работы и ты такйо хочешь сделать git commit; git push, а гит тебе "Нужно сначала спуллить изменения". Можно конечно просто сделать пулл, и история коммитов очень закакается, и чтоб этого не было делаем git pull --rebase

git merge <ОТКУДА БРАТЬ ИЗМЕНЕНИЯ ЧТОБ ВЛИТЬ В МЕНЯ>

gitk - Чудеснейшая утиллита просмотра лога коммитов с UI

git reset <file_name>

.git/info/exclude -- эксклюзивный .gitignore файл, который виден только для меня. Для остальных участников команды он невиден.

ПРИМЕР:
	*.log -- будут исключены ВСЕ файлы с таким расширением из ВСЕХ папок

git update-index --assume-unchanged path/to/file  ---- выкидываем файл из отслеживаемых
git update-index --no-assume-unchanged path/to/file -- добавлем обратно файл в отслеживаеые

*********git submodule*********

git submodule add <url> - добавляем подмодуль к текущему git-проекту
git clone <url> - стаскиваем себе проект уже с добавленным подмодулем, но он будет с пустой директорией подмодуля
		для того чтоб появилось его соделжимое нужно выполнить 
git submodule init и git submodule update - если делали git clone, то необходимо еще инит и апдейт делать

git submodule update --remote <submodule-dir> --merge|--rebase стаскиваем себе изменения
 подмодуля с удаленной репы с указанием типа слияния (мержд/ребейз).

git submodule foreach 'git status' - смотрим изменния, в подмодулях

Сливаем данные. Тут посложнее чем кажется. Делая просто push из родительского проекта, мы не захватим изменения из подмодулей.
Для того чтоб избежать этого нужно сделать:
а) закомитить изменния сделанные и в основной репе и в подмодуле. Изменения из подмодуля должны ОБЯЗАТЕЛЬНО попасть в коммит!
(тот случай когда git add . будет нелишним)))
б) сделать git push --recurse-submodules=check или =on-demand. В первом случае пуш прервется если в подмодулях есть непротолкнутые коммиты,
во втором - гит сам попытается запушить локальные коммиты, которые есть в подмодулях

*** удаляем подмодуль ***

submodule="ukf"

git rm "$submodule"
rm -rf ".git/modules/$submodule"
git config -f ".git/config" --remove-section "submodule.$submodule" 2> /dev/null

# Commit the change
git commit -m "Remove submodule $submodule"

*** удалили ***

********** rebase **********

git checkout feature/...
git rebase [НА] master        // ребейзнулись на мастер [feature/... поставили на master]

git rebase <КУДА> <ОТКУДА> т.е. передаем два указателя на ветки - на первую перетаскиваем коммиты со второй
в данном случае делаем так:
git rebase master feature/  <=> git rebase [НА] master
разница лишь в том что во втором случае гит за нас сделает git checkout feature/ по дефолту

git rebase -i - интерактивный режим. ВАЖНО! Перенося таким образом последний коммит из ветки <ОТКУДА>,
он не просто сам переедет на <КУДА>, но и сама ветка <ОТКУДА> начнет расти от <КУДА> и вся ее
богатая история коммитов затрется, останется только один последний.

Если надо перенести какие-то коммиты с одной ветки на другую проще воспользоваться cherry-pick
Допустим хотим стащить коммит с ветки feature/ на ветку master
git checkout master - встаем на ветку куда хотим стащить изменения
git cherry-pick commitSha - стаскиваем себе нужный коммит
 
Далее, если речь шла о переносе то нужно удалить коммит из feature/

git checkout feature/ - встаем на исходную ветку
git reset --hard HEAD~1 - удаляем последний коммит



git stash save -p -u - пробегается по всем файлам и спрашивает будем сташить или нет про каждый(че-то не сработало)





